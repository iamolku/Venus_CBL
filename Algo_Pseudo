What happens in each case?
Basic Movement
->Explore function (based on explored/unexplored)


Going around
    -> e.g. turn right move distance x forward depending on size of block/grid (applies to next 2 moves as well to make sure robot half-circumnavigates the block
    -> turn left & move forward distance 2x
    -> turn left & move forward x
    -> turn left one more time (Check if the block is still there, so it has successfully moved post the block)
    -> turn 180deg and keep exploring

*keep in mind, after every move update orientation*

Block detected
-> Size Determined (Infra sensor)
-> Move closer to determine color
-> Detect
    -> In the case that right or left is undiscovered, turn accordingly, and proceed as usual (explore function)
    -> else 
          -> Must go around
          -> e.g. turn right move certain dist forward depending on size of block/grid (applies to next 2 moves as well to make sure robot half-circumnavigates the block
          -> turn left
          -> turn left 
          -> turn left one more time (Check if the block is still there, so it has successfully moved post the block
          -> turn 180deg and keep exploring

Differentiating border and cliff

//^Utter nonsense

// code deciding whether to choose
int turn_clockwise_90(int orientation) {
    return (orientation + 90) % 360;
}

int turn_anticlockwise_90(int orientation) {
    return (orientation + 270) % 360;  // equivalent to -90 in modular arithmetic
}

int count_unvisited_in_direction(pos currpos, matrix_t matrix, int orientation) {
    int count = 0;
    int x = currpos.x;
    int y = currpos.y;

    while (true) {
        switch (orientation) {
            case 0:  // North
                y--;
                break;
            case 90:  // East
                x++;
                break;
            case 180:  // South
                y++;
                break;
            case 270:  // West
                x--;
                break;
        }
        if (x < 0 || x >= 300 || y < 0 || y >= 300 || matrix.grid[x][y] != NULL) {
            //300 set here as an example limit, to be changed once actual matrix size has been determined
            break;
        }
        count++;
    }
    return count;
}

// function to decide best direction based on unvisited spaces
char optimal_direction(pos currpos, matrix_t matrix, int orientation) {
    int right_orientation = turn_clockwise_90(orientation);
    int left_orientation = turn_anticlockwise_90(orientation);

    int right_unvisited = count_unvisited_in_direction(currpos, matrix, right_orientation);
    int left_unvisited = count_unvisited_in_direction(currpos, matrix, left_orientation);

    if (right_unvisited > left_unvisited) {
        return 'R';  // Turn right
    } else {
        return 'L';  // Turn left
    }
}
// can also set this to return integers if needed
//next up - what if both sides are visited + what if optimal is to go around obstacle.

//VOL 2 - counts unvisited spaces even if the robot itself is surrounded by visited spaces (just ignores visited)

int count_unvisited_beyond_visited(pos currpos, matrix_t matrix, int orientation) {
    int count = 0;
    bool visited_encountered = false;
    int x = currpos.x;
    int y = currpos.y;

    while (true) {
        switch (orientation) {
            case 0:  // North
                y--;
                break;
            case 90:  // East
                x++;
                break;
            case 180:  // South
                y++;
                break;
            case 270:  // West
                x--;
                break;
        }

        // Stop if out of bounds
        if (x < 0 || x >= 300 || y < 0 || y >= 300) break;

        // Get the current cell value
        char cell = matrix.grid[x][y];

        // Stop counting if an obstacle is encountered
        if (cell != NULL && cell != '+') {
            break;
        }

        // Count unvisited cells only after the first visited space has been encountered
        if (cell == NULL && visited_encountered) {
            count++;
        } else if (cell == '+') {
            visited_encountered = true; // Mark that visited space is encountered, continue counting
        }
    }
    return count;
}

char best_direction_to_turn(pos currpos, matrix_t matrix, int orientation) {
    int right_orientation = turn_clockwise_90(orientation);
    int left_orientation = turn_anticlockwise_90(orientation);

    int right_unvisited = count_unvisited_beyond_visited(currpos, matrix, right_orientation);
    int left_unvisited = count_unvisited_beyond_visited(currpos, matrix, left_orientation);

    // Determine the best direction based on the count of unvisited spaces
       if (right_unvisited > left_unvisited) {
        return 'R';  // Turn right
    } else {
        return 'L';  // Turn left
    }
}

//Now what if the the optimal is to go around the object
//Turning right and left is always preferable as it leaves less room for error but in the case that it is easier to go around the object we should

//VOL 3 - in the case of a big difference in unvisited squares, tells robot to go around the obstacle

int count_unvisited_beyond_visited(pos currpos, matrix_t matrix, int orientation) {
    int count = 0;
    bool visited_encountered = false;
    int x = currpos.x;
    int y = currpos.y;

    while (true) {
        switch (orientation) {
            case 0:  // North
                y--;
                break;
            case 90:  // East
                x++;
                break;
            case 180:  // South
                y++;
                break;
            case 270:  // West
                x--;
                break;
        }

        // Stop if out of bounds
        if (x < 0 || x >= 300 || y < 0 || y >= 300) break;

        // Get the current cell value
        char cell = matrix.grid[x][y];

        // Stop counting if an obstacle is encountered
        if (cell != NULL && cell != '+') {
            break;
        }

        // Count unvisited cells only after the first visited space has been encountered
        if (cell == NULL && visited_encountered) {
            count++;
        } else if (cell == '+') {
            visited_encountered = true; // Mark that visited space is encountered, continue counting
        }
    }
    return count;
}

int count_unvisited_straight(pos currpos, matrix_t matrix, int orientation){
    int count = 0;
    bool visited_encountered = false;
    int x = currpos.x;
    int y = currpos.y;

    while (true) {
        switch (orientation) {
            case 0:  // North
                y--;
                break;
            case 90:  // East
                x++;
                break;
            case 180:  // South
                y++;
                break;
            case 270:  // West
                x--;
                break;
        }

        // Stop if out of bounds
        if (x < 0 || x >= 300 || y < 0 || y >= 300) break;

        // Get the current cell value
        char cell = matrix.grid[x][y];

        // Stop counting if an obstacle is encountered
        if (cell != NULL && cell != '+') {
            break;
        }

        // Count unvisited cells only after the first visited space has been encountered
        if (cell == NULL && visited_encountered) {
            count++;
        } else if (cell == '+') {
            visited_encountered = true; // Mark that visited space is encountered, continue counting
        }
    }
    return count;
}

char optimal_direction (pos currpos, matrix_t matrix, int orientation) {
    int right_orientation = turn_clockwise_90(orientation);
    int left_orientation = turn_anticlockwise_90(orientation);

    int right_unvisited = count_unvisited_beyond_visited(currpos, matrix, right_orientation);
    int left_unvisited = count_unvisited_beyond_visited(currpos, matrix, left_orientation);
    int straight_unvisited = count_unvisited_straight(currpos, matrix, orientation);


    // Determine the best direction based on the count of unvisited spaces
       if (right_unvisited > left_unvisited) {
        return 'R';  // Turn right
    } else {
        return 'L';  // Turn left
    }
}






